generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id             String            @id @default(uuid())
  email          String            @unique
  password       String
  firstName      String
  lastName       String
  role           UserRole          @default(READER)
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  assignedMeters MeterAssignment[]
  notifications  Notification[]
  readings       Reading[]

  @@map("users")
}

model Location {
  id          String   @id @default(uuid())
  name        String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  meters      Meter[]

  @@map("locations")
}

model MeterType {
  id          String   @id @default(uuid())
  name        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  meters Meter[]

  @@map("meter_types")
}

model Meter {
  id            String           @id @default(uuid())
  meterNumber   String           @unique
  meterTypeId   String
  locationId    String
  frequency     ReadingFrequency
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  // Relations
  location        Location          @relation(fields: [locationId], references: [id], onDelete: Cascade)
  meterType       MeterType         @relation(fields: [meterTypeId], references: [id], onDelete: Restrict)
  assignments     MeterAssignment[]
  readings        Reading[]
  scheduledReadings ScheduledReading[]

  @@map("meters")
}

model MeterAssignment {
  id         String   @id @default(uuid())
  meterId    String
  userId     String
  assignedAt DateTime @default(now())
  assignedBy String?
  meter      Meter    @relation(fields: [meterId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([meterId, userId])
  @@map("meter_assignments")
}

model ScheduledReading {
  id            String   @id @default(uuid())
  meterId       String
  scheduledDate DateTime
  dueDate       DateTime
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  meter         Meter    @relation(fields: [meterId], references: [id], onDelete: Cascade)

  @@map("scheduled_readings")
}

model Reading {
  id          String   @id @default(uuid())
  meterId     String
  userId      String
  value       Float
  readingDate DateTime @default(now())
  comment     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  meter       Meter    @relation(fields: [meterId], references: [id], onDelete: Cascade)
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([meterId])
  @@index([userId])
  @@index([readingDate])
  @@map("readings")
}

model Notification {
  id        String             @id @default(uuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  createdAt DateTime           @default(now())
  metadata  Json?
  readAt    DateTime?
  status    NotificationStatus @default(UNREAD)
  user      User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status])
  @@map("notifications")
}

enum UserRole {
  ADMIN
  READER
}

enum ReadingFrequency {
  DAILY
  WEEKLY
  MONTHLY
  AD_HOC
}

enum NotificationType {
  NEW_ASSIGNMENT
  READING_DUE
  READING_MISSED
}

enum NotificationStatus {
  UNREAD
  READ
}
